{"name":"Recommender System","tagline":"Collaborative Filtering","body":"## Description\r\nFor businesses it is important to have knowledge about what users enjoy buying in order to provide them with better shopping experience. For example, a person buying a new television may frequently buy a surge protector to go along with it. What a recommender system does calculate the probability that a person consuming an item would likely need. Providing an opportunity for the business to sell another item.\r\n\r\nFor this project we will be applying the same logic to movie recommendations. Given a history of what a user has watched, we will try to recommend items that they would also be interested in seeing.\r\n\r\n## Methods\r\n### Data Set\r\nThe data set used for this project comes from the GroupLens Movie data set of 1 million ratings ([GroupLens](http://grouplens.org/datasets/movielens/)). The dataset contains demographic information and rating data for over 6000 users for 4000 movies.\r\n\r\n### Methodology\r\nHere we explore the use of Collaborative filtering ([Wikipedia](https://en.wikipedia.org/wiki/Collaborative_filtering)) in order to make our recommendations. Collaborative Filtering can be done with various methods. Our chosen methods was to do an item-item collaborative filtering which in essence says \"users who bought x also bought y\". This method first applies a similarity between items. There is then an option to do an additional user-based filtering to find individual recommendations, which we will also do.\r\n\r\nFor this use of item-based collaborative filtering, we'll be finding the similarity of the movies to each other by finding the Cosine Similarity between matrices. Denoted: \r\n![Similarity Function](https://upload.wikimedia.org/math/4/e/4/4e45dc7ae582130813e804f793f24ead.png) \r\nBased on users reviews, the rated movies are turned into a matrix where each movie has a list of movies that are similar to them. These matrix rows are then compared to with each other to get a similarity rating.\r\n\r\nFrom there the user layer is applied which takes the user's seen movies and finds the movies most similar to the ones already watched. This list is then sorted by similarity rating and output to a file.\r\n\r\n###Procedure\r\nTo measure the quality of the results. 3 random users were selected at random and 5 random movies were removed from their data set. \r\nIn an ideal scenario the recommendation system will recommend the movies which were removed to the user.\r\n## Results\r\n\r\n##Results and Discussion\r\nResults from the data executed did not show any of the movies removed in the top recommendations.\r\n\r\n***Table Soon***\r\n\r\nIt's hypothesized that this is because of some of the key downsides with collaborative filtering, and that is data sparsity. Given a that a movie set has on average of 250 ratings each, this would not seem to be a problem. However, with movie data the ratings are skewed towards those blockbusters and other popular movies while less popular movies are weighed heavily by the few votes they do have. \r\n![Image of RatingsCount](https://github.com/ARubberDucky/images/RatingCount.PNG)","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}